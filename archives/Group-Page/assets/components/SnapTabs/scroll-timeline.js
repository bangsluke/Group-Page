// scroll-timeline.js 

// Web Tabs (snap tabs) scripts
// https://web.dev/building-a-tabs-component/

//console.log("scroll-timeline.js loaded");

!function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function e(e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } function n(t) { var e = t.trim().match(/^(-?[0-9]*\.?[0-9]*)(px|%)$/); return e ? { value: e[1], unit: e[2] } : null } var i = new WeakMap, r = []; function o(t) { return t === document.scrollingElement ? document : t } function l(t) { var e = i.get(t).animations; if (0 !== e.length) for (var n = t.currentTime, r = 0; r < e.length; r++)null == n ? "paused" === e[r].playState && e[r].cancel() : e[r].currentTime = n } function a(t) { return Infinity === t.iterationCount ? Infinity : Math.max((t.startDelay || 0) + (t.duration || 0) * (t.iterationCount || 1) + (t.endDelay || 0), 0) } function s(t, e, i, r, o) { if (o) return o(e, i, r, "0%" === t ? "start" : "end"); "block" === i ? i = "vertical" : "inline" === i && (i = "horizontal"); var l = "vertical" === i ? e.scrollHeight - e.clientHeight : e.scrollWidth - e.clientWidth, a = n("auto" === r ? t : r); return "%" === a.unit ? parseFloat(a.value) * l / 100 : parseFloat(a.value) } var c = function () { function t(t) { i.set(this, { scrollSource: null, orientation: "block", startScrollOffset: "auto", endScrollOffset: "auto", timeRange: "auto", fill: "none", animations: [], animationOptions: [] }), this.scrollSource = t && t.scrollSource || document.scrollingElement, this.orientation = t && t.orientation || "block", this.startScrollOffset = t && t.startScrollOffset || "auto", this.endScrollOffset = t && t.endScrollOffset || "auto", this.timeRange = t && t.timeRange || "auto", this.fill = t && t.fill || "none" } return e(t, [{ key: "scrollSource", set: function (t) { var e = this; this.scrollSource && o(this.scrollSource).removeEventListener("scroll", function () { return l(e) }), t instanceof Element || (t = document.scrollingElement), i.get(this).scrollSource = t, o(t).addEventListener("scroll", function () { return l(e) }), l(this) }, get: function () { return i.get(this).scrollSource } }, { key: "orientation", set: function (t) { -1 === ["block", "inline", "horizontal", "vertical"].indexOf(t) && (t = "block"), i.get(this).orientation = t, l(this) }, get: function () { return i.get(this).orientation } }, { key: "startScrollOffset", set: function (t) { var e = i.get(this); e.startScrollOffsetFunction = null; for (var n = 0; n < r.length; n++) { var o = r[n].parse(t); if (void 0 !== o) { t = o, e.startScrollOffsetFunction = r[n].evaluate; break } } e.startScrollOffset = t, l(this) }, get: function () { return i.get(this).startScrollOffset } }, { key: "endScrollOffset", set: function (t) { i.get(this).endScrollOffsetFunction = null; for (var e = 0; e < r.length; e++) { var n = r[e].parse(t); if (void 0 !== n) { t = n, i.get(this).endScrollOffsetFunction = r[e].evaluate; break } } i.get(this).endScrollOffset = t, l(this) }, get: function () { return i.get(this).endScrollOffset } }, { key: "timeRange", set: function (t) { i.get(this).timeRange = t, l(this) }, get: function () { return i.get(this).timeRange } }, { key: "currentTime", get: function () { if (!this.scrollSource) return null; var t, e, n = s("0%", this.scrollSource, this.orientation, this.startScrollOffset, i.get(this).startScrollOffsetFunction), r = s("100%", this.scrollSource, this.orientation, this.endScrollOffset, i.get(this).endScrollOffsetFunction), o = function (t) { var e = t.timeRange; if ("auto" === e) { e = 0; for (var n = i.get(t).animationOptions, r = 0; r < n.length; r++)e = Math.max(e, a(n[r])); Infinity === e && (e = 0) } return e }(this), l = this.scrollSource.scrollTop; return "inline" !== this.orientation && "horizontal" !== this.orientation || (l = this.scrollSource.scrollLeft), l < n ? "none" === this.fill || "forwards" === this.fill ? null : 0 : l >= r ? r < (t = this.scrollSource, "block" === (e = this.orientation) ? e = "vertical" : "inline" === e && (e = "horizontal"), "vertical" === e ? t.scrollHeight - t.clientHeight : "horizontal" === e ? t.scrollWidth - t.clientWidth : void 0) && ("none" === this.fill || "backwards" === this.fill) ? null : o : (l - n) / (r - n) * o } }, { key: "__polyfill", get: function () { return !0 } }]), t }(), u = new WeakMap, h = [[[0, 1, 2, 3]], [[0, 2], [1, 3]], [[0], [1, 3], [2]], [[0], [1], [2], [3]]], f = function () { function t(t) { u.set(this, { target: null, edge: "start", threshold: 0, rootMargin: [[0, "px"], [0, "px"], [0, "px"], [0, "px"]] }), this.target = t.target, this.edge = t.edge || "start", this.threshold = t.threshold || 0, this.rootMargin = t.rootMargin || "0px 0px 0px 0px", this.clamp = t.clamp || !1 } return e(t, [{ key: "target", set: function (t) { if (!(t instanceof Element)) throw u.get(this).target = null, Error("Intersection target must be an element."); u.get(this).target = t }, get: function () { return u.get(this).target } }, { key: "edge", set: function (t) { -1 != ["start", "end"].indexOf(t) && (u.get(this).edge = t) }, get: function () { return u.get(this).edge } }, { key: "threshold", set: function (t) { var e = parseFloat(t); if (e < 0 || e > 1) throw RangeError("threshold must be in the range [0, 1]"); u.get(this).threshold = e }, get: function () { return u.get(this).threshold } }, { key: "rootMargin", set: function (t) { var e = t.split(/ +/); if (e.length < 1 || e.length > 4) throw TypeError("rootMargin must contain between 1 and 4 length components"); for (var i = [[], [], [], []], r = 0; r < e.length; r++) { var o = n(e[r]); if (!o) throw TypeError("Unrecognized rootMargin length"); for (var l = h[e.length - 1][r], a = 0; a < l.length; a++)i[l[a]] = [parseFloat(o.value), o.unit] } u.get(this).rootMargin = i }, get: function () { return u.get(this).rootMargin.map(function (t) { return t.join("") }).join(" ") } }, { key: "clamp", set: function (t) { u.get(this).clamp = !!t } }]), t }(), g = window.Element.prototype.animate; if (r.push({ parse: function (t) { if (t.target) return new f(t) }, evaluate: function (t, e, n, i) { "block" == e ? e = "vertical" : "inline" == e && (e = "horizontal"); for (var r, o = t == document.scrollingElement ? { left: 0, right: t.clientWidth, top: 0, bottom: t.clientHeight, width: t.clientWidth, height: t.clientHeight } : t.getBoundingClientRect(), l = u.get(n).rootMargin, a = [], s = 0; s < 4; s++)a.push("%" == (r = l[s])[1] ? r[0] * (s % 2 == 0 ? o.height : o.width) / 100 : r[0]); var c = o.left - a[3], h = o.right - o.left + a[3] + a[1], f = o.top - a[0], g = o.bottom - o.top + a[0] + a[2], d = u.get(n).clamp, m = n.target.getBoundingClientRect(), p = n.threshold; if ("start" == n.edge && (p = 1 - p), "vertical" == e) { var v = m.top + m.height * p - f + t.scrollTop; return d ? "end" == n.edge ? Math.max(0, v - g) : Math.min(v, t.scrollHeight - g) : "end" == n.edge ? v - g : v } var S = m.left + m.width * p - c + t.scrollLeft; return d ? "end" == n.edge ? Math.max(0, S - h) : Math.min(S, t.scrollWidth - h) : "end" == n.edge ? S - h : S } }), !Reflect.defineProperty(window, "ScrollTimeline", { value: c })) throw Error("Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window"); if (!Reflect.defineProperty(Element.prototype, "animate", { value: function (t, e) { var n = e.timeline; if (!(n && n instanceof c)) return g.apply(this, [t, e]); delete e.timeline; var r = g.apply(this, [t, e]); return r.pause(), function (t, e, n) { var r = i.get(t).animations, o = i.get(t).animationOptions; r.push(e), o.push(n), l(t) }(n, r, e), r } })) throw Error("Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element") }();
//# sourceMappingURL=scroll-timeline.js.map